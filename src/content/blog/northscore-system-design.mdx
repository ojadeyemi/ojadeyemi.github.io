import Image from "next/image";

export const metadata = {
  title: "Building Northscore: System Design for a Canadian Sports Platform",
  description:
    "How I built a scalable sports data platform serving live stats across Canadian leagues from a single codebase.",
  publishDate: "2026-01-03",
  tags: ["System Design", "PWA", "FastAPI", "Architecture"],
  readTime: "4 min read",
  thumbnail: "/img/northscore-screenshots-grid.png",
};

<FadeIn>

# Building Northscore

_A system design case study_

</FadeIn>

<SlideIn delay={0.2}>

There was no single place to follow Canadian sports. So I built one.

**Northscore** is a Progressive Web App that delivers live stats, standings, and aggregated media across Canadian leagues — all from a single codebase.

</SlideIn>

<FadeIn delay={0.3}>

<VideoDialog
  videoId="3v5uWRAhyG4"
  title="Northscore — Product Demo"
  description="Watch the product in action"
/>

</FadeIn>

---

## What It Does

<SlideIn delay={0.2}>

<div className="not-prose my-8 grid grid-cols-2 gap-3">
  <Image
    src="/img/northscore_screenshot0.png"
    alt="Northscore live scores"
    width={390}
    height={844}
    className="rounded-lg"
  />
  <Image
    src="/img/northscore_screenshot1.png"
    alt="Northscore standings"
    width={390}
    height={844}
    className="rounded-lg"
  />
</div>

</SlideIn>

<StaggerChildren>

<StaggerItem>

**Live stats & standings** — The app tracks real-time scores across the CFL, CEBL, CHL, CPL, and more. Game data updates automatically, so you're always seeing current standings and results.

</StaggerItem>

<StaggerItem>

**Aggregated content** — Instead of jumping between websites and apps, Northscore indexes articles, podcasts, and YouTube videos from across Canadian sports media. Everything shows up in one feed.

</StaggerItem>

<StaggerItem>

**Installable anywhere** — It runs on iOS, Android, desktop, and even Meta Quest. There's no app store involved. You just install it from the browser, and it behaves like a native app.

</StaggerItem>

<StaggerItem>

**Push notifications** — Users only get notifications for the teams they actually follow. No spam, no irrelevant alerts.

</StaggerItem>

</StaggerChildren>

---

## System Architecture

<FadeIn delay={0.2}>

<Image
  src="/img/northscore-architecture.png"
  alt="Northscore System Architecture"
  width={1200}
  height={800}
  className="my-6 rounded-lg"
/>

</FadeIn>

<SlideIn delay={0.3}>

The system is built in three layers. Each one scales independently.

</SlideIn>

<StaggerChildren>

<StaggerItem>

**Frontend** — The Next.js PWA is deployed to an edge CDN. This means the app shell is cached globally, users get fast initial loads, and there are no cold starts. The same codebase serves every device.

</StaggerItem>

<StaggerItem>

**Backend** — FastAPI containers run stateless. No session state, no sticky routing. When traffic spikes, containers scale horizontally. When traffic drops, they scale back down. I don't manage servers.

</StaggerItem>

<StaggerItem>

**Data layer** — PostgreSQL stores structured data. Redis handles fast cache reads. SQLite provides league-specific isolation when needed. Each tool does what it's good at.

</StaggerItem>

<StaggerItem>

**Ingestion** — Custom scrapers and API wrappers pull data from various sources and normalize it into a unified schema. The frontend doesn't care whether data came from an official API or a web scraper — it's all the same shape by the time it arrives.

</StaggerItem>

</StaggerChildren>

<InfoAside>

Every league maps to the same data model. The frontend doesn't need to know where the data came from.

</InfoAside>

---

## One Codebase, Every Device

<FadeIn delay={0.2}>

I chose a PWA over native apps for a simple reason: I'm one person.

</FadeIn>

<SlideIn delay={0.3}>

Building separate iOS, Android, and web apps would mean maintaining three codebases, fixing three sets of bugs, and managing three deployment pipelines. That's not realistic for a solo project.

Instead, one Next.js app runs everywhere — phones, tablets, desktops, even VR headsets. There are no app store approval delays. Updates are instant for all users. The same code runs on every device.

</SlideIn>

---

## How Data Flows

<FadeIn delay={0.2}>

<InteractiveRequestFlow />

</FadeIn>

<SlideIn delay={0.3}>

Most requests never hit the database. The system is cache-first, so response times stay low even when traffic spikes.

When a user opens the app, the CDN serves the PWA shell. Then the app makes an API request. That request checks Redis first. If the data is cached, it's returned immediately. If there's a cache miss, the database gets queried, the response is normalized, and it's stored in Redis for the next request.

This keeps the Stats API p90 latency under 100ms, even on game days when traffic is high.

</SlideIn>

```python
@app.get("/teams/{team_id}")
async def get_team(team_id: str):
    # Check cache first
    if cached := redis.get(team_id):
        return cached

    # Cache miss — query database
    team = db.fetch_team(team_id)
    redis.set(team_id, team, ex=300)  # 5 min TTL
    return team
```

<SuccessAside>

Stats API p90 latency under 100ms. Even on game days.

</SuccessAside>

---

## The Data Problem

<FadeIn delay={0.2}>

Canadian sports data is fragmented. Some leagues have APIs. Most don't.

</FadeIn>

<StaggerChildren>

<StaggerItem>

**Leagues with APIs** — For leagues that provide official APIs, I built SDK wrappers with proper error handling, retries, and documentation. The [CFL SDK](https://github.com/ojadeyemi/cfl-sdk) is open source and handles rate limiting, pagination, and schema validation automatically.

</StaggerItem>

<StaggerItem>

**Leagues without APIs** — For leagues without official data sources, I built custom scrapers that fetch and normalize data on a schedule. These run reliably, handle failures gracefully, and keep the app updated even when source websites change their markup.

</StaggerItem>

<StaggerItem>

**HoopQueens** — This league had no data infrastructure at all, so I built it from scratch. I created an AI-powered tool that takes raw box scores from the league, auto-extracts the data schema using an agent, previews it for validation, and saves it to the database. What used to be manual data entry is now done in seconds.

</StaggerItem>

</StaggerChildren>

<WarningAside title="Lesson learned">

Data ingestion is 80% of the work. The app itself is the easy part.

</WarningAside>

---

## Auth & Personalization

<FadeIn delay={0.2}>

Northscore uses passwordless authentication. Users sign in with Google, Microsoft, or email OTP. No passwords are stored anywhere.

</FadeIn>

<SlideIn delay={0.3}>

A managed auth backend handles everything user-related: accounts, favorite teams, notification preferences, upcoming games tracking. The stats API doesn't know who you are. It just serves data. This separation keeps the architecture clean and makes the stats API fast — it's stateless and cacheable.

Onboarding is intentionally simple: install the app, sign up, enable notifications. Three steps. No friction.

</SlideIn>

---

## Keeping It Running

<FadeIn delay={0.2}>

Everything in the system is stateless. Services scale horizontally by default.

</FadeIn>

<StaggerChildren>

<StaggerItem>

**CI/CD** — Every commit is linted, formatted, and tested automatically. Pull requests are reviewed with Gemini Code Assist to catch issues before they merge. If any check fails, the deployment is blocked. If a deployment introduces a breaking change, it rolls back automatically. This means I can ship often without worrying about breaking production.

</StaggerItem>

<StaggerItem>

**Observability** — Logs, traces, and Slack alerts catch issues before users notice them. When something breaks, I know immediately. When performance degrades, I get a notification. This makes debugging fast and keeps the app reliable.

</StaggerItem>

<StaggerItem>

**Auto-healing** — If a container crashes, it restarts automatically. If a service becomes unhealthy, it's replaced. There's no manual intervention required. The system is designed to recover on its own.

</StaggerItem>

</StaggerChildren>

<SuccessAside>

99.99% uptime since launch. Zero-downtime deployments.

</SuccessAside>

---

<FadeIn delay={0.3}>

> Northscore isn't built to _look_ scalable.
> It's built to _stay simple_ as it scales.

</FadeIn>

<SlideIn delay={0.4}>

There's still a lot to improve. Better personalization. More leagues. Smarter notifications. But the foundation is solid. And that's what matters.

</SlideIn>
